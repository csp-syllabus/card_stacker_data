import { Texture, Point } from '@pixi/core';
import { Container } from '@pixi/display';
import { Graphics } from '@pixi/graphics';
import { Sprite } from '@pixi/sprite';
import { Text } from '@pixi/text';
import { Signal } from 'typed-signals';
import { removeHitBox } from './utils/helpers/hitbox.mjs';

class Slider extends Container {
  constructor(options) {
    super();
    this.dragging = 0;
    /** TODO */
    this.percent = 100;
    /** TODO */
    this.value = 0;
    /** TODO */
    this.onChange = new Signal();
    this.options = options;
    const bg = typeof options.bg === "string" ? new Sprite(Texture.from(options.bg)) : options.bg;
    this.bg = new Container();
    this.bg.addChild(bg);
    this.addChild(this.bg);
    if (options.fill) {
      const fill = typeof options.fill === "string" ? new Sprite(Texture.from(options.fill)) : options.fill;
      this.fill = new Container();
      this.fill.addChild(fill);
      const offsetX = options.fillOffset?.x ?? 0;
      const offsetY = options.fillOffset?.y ?? 0;
      this.fill.x = (this.bg.width - this.fill.width) / 2 + offsetX;
      this.fill.y = (this.bg.height - this.fill.height) / 2 + offsetY;
      this.fillMask = new Graphics();
      this.fill.addChild(this.fillMask);
      this.fill.mask = this.fillMask;
      this.addChild(this.fill);
    }
    const slider = typeof options.slider === "string" ? new Sprite(Texture.from(options.slider)) : options.slider;
    slider.x = slider.width / 2;
    this.slider = new Container();
    this.slider.addChild(slider);
    if (slider instanceof Sprite) {
      slider.anchor.set(0.5);
    }
    this.slider.y = this.bg.height / 2;
    this.addChild(this.slider);
    if (options.showValue) {
      this.valueText = new Text(
        "",
        options.valueTextStyle || { fill: 16777215 }
      );
      this.valueText.anchor.set(0.5);
      this.addChild(this.valueText);
    }
    this.makeScrollable();
    this.validateSettings();
    this.update();
  }
  validateSettings() {
    const { options } = this;
    if (!options.min) {
      options.min = 0;
    }
    if (!options.max) {
      options.max = 100;
    }
    if (options.value < options.min) {
      options.value = options.min;
    }
    if (options.value > options.max) {
      options.value = options.max;
    }
    this.value = options.value ?? options.min ?? 0;
    this.percent = this.value * 100 / options.max;
    const scale = options.max - options.min;
    const scaledVal = this.value - options.min;
    this.percent = scaledVal * 100 / scale;
  }
  makeScrollable() {
    this.interactive = true;
    this.slider.interactive = true;
    this.bg.interactive = true;
    const { onSetByClick, onDragStart, onDragMove, onDragEnd } = this;
    this.slider.on("pointerdown", onDragStart, this).on("pointermove", onDragMove, this).on("pointerup", onDragEnd, this).on("pointerupoutside", onDragEnd, this);
    this.bg.on("pointerdown", onSetByClick, this);
    this.on("pointerupoutside", onDragEnd, this);
    removeHitBox(this.fill, this.valueText);
  }
  onSetByClick(event) {
    const obj = event.currentTarget;
    let pos = obj.parent.worldTransform.applyInverse(event.global).x - this.slider.width / 2;
    if (pos < 0) {
      pos = 0;
    }
    if (pos < 0) {
      pos = 0;
    }
    const maxPos = this.bg.width - this.slider.width;
    if (pos > maxPos) {
      pos = maxPos;
    }
    this.percent = Math.round(pos / maxPos * 100);
    this.value = this.options.min + Math.round(
      (this.options.max - this.options.min) / 100 * this.percent
    );
    this.update();
    this.onChange?.emit(this.value);
  }
  onDragStart(event) {
    const obj = event.currentTarget;
    obj.dragData = event;
    this.dragging = 1;
    obj.dragPointerStart = obj.parent.worldTransform.applyInverse(event.global);
    obj.dragObjStart = new Point();
    obj.dragObjStart.copyFrom(obj.position);
    obj.dragGlobalStart = new Point();
    obj.dragGlobalStart.copyFrom(event.data.global);
  }
  onDragMove(event) {
    const obj = event.currentTarget;
    if (!this.dragging) {
      return;
    }
    const data = obj.dragData;
    if (this.dragging === 1) {
      if (Math.abs(data.global.x - obj.dragGlobalStart?.x) + Math.abs(data.global.y - obj.dragGlobalStart?.y) >= 3) {
        this.dragging = 2;
      }
    }
    if (this.dragging === 2) {
      const dragPointerEnd = obj.parent.worldTransform.applyInverse(data.global);
      let pos = obj.dragObjStart.x + (dragPointerEnd.x - obj.dragPointerStart.x);
      if (pos < 0) {
        pos = 0;
      }
      const maxPos = this.bg.width - this.slider.width;
      if (pos > maxPos) {
        pos = maxPos;
      }
      this.percent = Math.round(pos / maxPos * 100);
      this.value = this.options.min + Math.round(
        (this.options.max - this.options.min) / 100 * this.percent
      );
      this.update();
    }
  }
  onDragEnd() {
    if (!this.dragging) {
      return;
    }
    this.dragging = 0;
    this.onChange?.emit(this.value);
  }
  update(pos) {
    const position = pos ?? (this.bg.width - this.slider.width) / 100 * this.percent;
    this.slider.x = position;
    const startPoint = 0;
    const endPoint = this.bg.width / 100 * this.percent;
    if (this.fillMask) {
      this.fillMask.clear().lineStyle(0).beginFill(16777215).drawRect(
        startPoint,
        0,
        endPoint - startPoint,
        this.fill.height
      );
    }
    if (this.options.showValue) {
      this.valueText.text = this.value;
      const sliderPosX = this.slider.x + this.slider.width / 2;
      const sliderPosY = this.slider.y;
      this.valueText.x = sliderPosX + (this.options.valueTextOffset?.x ?? 0);
      this.valueText.y = sliderPosY + (this.options.valueTextOffset?.y ?? 0);
    }
    this.onChange?.emit(this.value);
  }
}

export { Slider };
//# sourceMappingURL=Slider.mjs.map
