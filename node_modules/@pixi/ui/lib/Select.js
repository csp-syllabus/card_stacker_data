'use strict';

var core = require('@pixi/core');
var display = require('@pixi/display');
var graphics = require('@pixi/graphics');
var sprite = require('@pixi/sprite');
var text = require('@pixi/text');
var typedSignals = require('typed-signals');
var Button = require('./Button.js');
var ScrollBox = require('./ScrollBox.js');

class Select extends display.Container {
  constructor({
    closedBG,
    textStyle,
    items,
    openBG,
    selected,
    selectedTextOffset,
    scrollBox
  }) {
    super();
    this.closedBG = typeof closedBG === "string" ? new sprite.Sprite(core.Texture.from(closedBG)) : closedBG;
    this.openBG = typeof openBG === "string" ? new sprite.Sprite(core.Texture.from(openBG)) : openBG;
    this.openBG.visible = false;
    this.addChild(this.closedBG, this.openBG);
    const openButton = new Button.Button({
      view: this.closedBG
    });
    this.addChild(openButton);
    openButton.onPress.connect(() => this.toggle());
    this.selectedText = new text.Text(
      items?.items ? items.items[0] : "",
      textStyle
    );
    const selectedTextButton = new Button.Button({
      view: this.selectedText
    });
    selectedTextButton.onPress.connect(() => this.toggle());
    this.addChild(selectedTextButton);
    this.selectedText.anchor.set(0.5);
    this.selectedText.x = this.closedBG.width / 2 + (selectedTextOffset?.x || 0);
    this.selectedText.y = this.closedBG.height / 2 + (selectedTextOffset?.y || 0);
    this.scrollBox = new ScrollBox.ScrollBox({
      type: "vertical",
      elementsMargin: 0,
      width: this.closedBG.width,
      height: this.closedBG.height * 5,
      radius: 0,
      padding: 0,
      ...scrollBox
    });
    this.openBG.addChild(this.scrollBox);
    this.scrollBox.y = this.closedBG.height;
    if (scrollBox?.offset) {
      this.scrollBox.x += scrollBox.offset.x ?? 0;
      this.scrollBox.y += scrollBox.offset.y ?? 0;
    }
    this.onSelect = new typedSignals.Signal();
    this.convertItemsToButtons(items).forEach((button, id) => {
      const text = button.getText();
      if (id === selected) {
        this.selectedText.text = text;
      }
      button.onPress.connect(() => {
        this.value = id;
        this.onSelect.emit(id, text);
        this.selectedText.text = text;
        this.close();
      });
      this.scrollBox.addItem(button);
    });
  }
  /** TODO */
  toggle() {
    this.openBG.visible = !this.openBG.visible;
    this.closedBG.visible = !this.closedBG.visible;
  }
  /** TODO */
  open() {
    this.openBG.visible = true;
    this.closedBG.visible = false;
  }
  /** TODO */
  close() {
    this.openBG.visible = false;
    this.closedBG.visible = true;
  }
  convertItemsToButtons({
    items,
    backgroundColor,
    hoverColor,
    width,
    height,
    textStyle,
    radius
  }) {
    const buttons = [];
    items.forEach((item) => {
      const view = new graphics.Graphics().beginFill(backgroundColor).drawRoundedRect(0, 0, width, height, radius);
      const hoverView = new graphics.Graphics().beginFill(hoverColor ?? backgroundColor).drawRoundedRect(0, 0, width, height, radius);
      const textView = new text.Text(item, textStyle);
      const button = new Button.Button({ view, hoverView, textView });
      buttons.push(button);
    });
    return buttons;
  }
  /** TODO */
  update() {
    this.scrollBox.update();
  }
}

exports.Select = Select;
//# sourceMappingURL=Select.js.map
