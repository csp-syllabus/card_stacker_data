import { Texture } from '@pixi/core';
import { Container } from '@pixi/display';
import { Graphics } from '@pixi/graphics';
import { Sprite } from '@pixi/sprite';
import { Text } from '@pixi/text';
import { Signal } from 'typed-signals';
import { Button } from './Button.mjs';
import { ScrollBox } from './ScrollBox.mjs';

class Select extends Container {
  constructor({
    closedBG,
    textStyle,
    items,
    openBG,
    selected,
    selectedTextOffset,
    scrollBox
  }) {
    super();
    this.closedBG = typeof closedBG === "string" ? new Sprite(Texture.from(closedBG)) : closedBG;
    this.openBG = typeof openBG === "string" ? new Sprite(Texture.from(openBG)) : openBG;
    this.openBG.visible = false;
    this.addChild(this.closedBG, this.openBG);
    const openButton = new Button({
      view: this.closedBG
    });
    this.addChild(openButton);
    openButton.onPress.connect(() => this.toggle());
    this.selectedText = new Text(
      items?.items ? items.items[0] : "",
      textStyle
    );
    const selectedTextButton = new Button({
      view: this.selectedText
    });
    selectedTextButton.onPress.connect(() => this.toggle());
    this.addChild(selectedTextButton);
    this.selectedText.anchor.set(0.5);
    this.selectedText.x = this.closedBG.width / 2 + (selectedTextOffset?.x || 0);
    this.selectedText.y = this.closedBG.height / 2 + (selectedTextOffset?.y || 0);
    this.scrollBox = new ScrollBox({
      type: "vertical",
      elementsMargin: 0,
      width: this.closedBG.width,
      height: this.closedBG.height * 5,
      radius: 0,
      padding: 0,
      ...scrollBox
    });
    this.openBG.addChild(this.scrollBox);
    this.scrollBox.y = this.closedBG.height;
    if (scrollBox?.offset) {
      this.scrollBox.x += scrollBox.offset.x ?? 0;
      this.scrollBox.y += scrollBox.offset.y ?? 0;
    }
    this.onSelect = new Signal();
    this.convertItemsToButtons(items).forEach((button, id) => {
      const text = button.getText();
      if (id === selected) {
        this.selectedText.text = text;
      }
      button.onPress.connect(() => {
        this.value = id;
        this.onSelect.emit(id, text);
        this.selectedText.text = text;
        this.close();
      });
      this.scrollBox.addItem(button);
    });
  }
  /** TODO */
  toggle() {
    this.openBG.visible = !this.openBG.visible;
    this.closedBG.visible = !this.closedBG.visible;
  }
  /** TODO */
  open() {
    this.openBG.visible = true;
    this.closedBG.visible = false;
  }
  /** TODO */
  close() {
    this.openBG.visible = false;
    this.closedBG.visible = true;
  }
  convertItemsToButtons({
    items,
    backgroundColor,
    hoverColor,
    width,
    height,
    textStyle,
    radius
  }) {
    const buttons = [];
    items.forEach((item) => {
      const view = new Graphics().beginFill(backgroundColor).drawRoundedRect(0, 0, width, height, radius);
      const hoverView = new Graphics().beginFill(hoverColor ?? backgroundColor).drawRoundedRect(0, 0, width, height, radius);
      const textView = new Text(item, textStyle);
      const button = new Button({ view, hoverView, textView });
      buttons.push(button);
    });
    return buttons;
  }
  /** TODO */
  update() {
    this.scrollBox.update();
  }
}

export { Select };
//# sourceMappingURL=Select.mjs.map
