import { Container } from '@pixi/display';
import { FederatedPointerEvent } from '@pixi/events';
import { Text } from '@pixi/text';
import { Signal } from 'typed-signals';
export interface ButtonOptions {
    view: Container;
    hoverView?: Container;
    pressedView?: Container;
    disabledView?: Container;
    textView?: Text;
    padding?: number;
    textOffset?: {
        x: number;
        y: number;
    };
}
/**
 * Container based component that gives us a starting point for UI buttons.
 * It composes a view rather than extends one, this means we can easily make any pixi container a button!
 * @example
 * ```
 * const spriteButton = new Button({
 *     view: new PixiSprite(Texture.from(`button.png`)),
 *     hoverView: new PixiSprite(Texture.from(`button_hover.png`)),
 *     pressedView: new PixiSprite(Texture.from(`button_pressed.png`)),
 *     disabledView: new PixiSprite(Texture.from(`button_disabled.png`)),
 *     textView: new Text(text, { fill: 0xFFFFFF }),
 * });
 *
 * const graphicsButton = new Button({
 *     view: new PixiGraphics().beginFill(color).drawRoundedRect(0, 0, width, height, radius),
 *     hoverView: new PixiGraphics().beginFill(hoverColor).drawRoundedRect(0, 0, width, height, radius),
 *     pressedView: new PixiGraphics().beginFill(pressedColor).drawRoundedRect(0, 0, width, height, radius),
 *     disabledView: new PixiGraphics().beginFill(disabledColor).drawRoundedRect(0, 0, width, height, radius),
 *     textView: new Text(text, { fill: 0xFFFFFF }),
 *     padding: 10,
 *     textOffset: { x: 10, y: 1 },
 * });
 *
 * ```
 */
export declare class Button extends Container {
    /** TODO */
    defaultView: Container;
    /** TODO */
    hoverView: Container;
    /** TODO */
    pressedView: Container;
    /** TODO */
    disabledView: Container;
    /** TODO */
    text: Text;
    /** TODO */
    onPress: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** TODO */
    onDown: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** TODO */
    onUp: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** TODO */
    onHover: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** TODO */
    onOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    /** TODO */
    onUpOut: Signal<(btn?: this, e?: FederatedPointerEvent) => void>;
    private _isDown;
    private _enabled;
    private _shown;
    private padding;
    constructor({ view, hoverView, pressedView, disabledView, textView, padding, textOffset, }: ButtonOptions);
    /**
     * TODO
     * @param _e
     */
    down(_e?: FederatedPointerEvent): void;
    /**
     * TODO
     * @param _e
     */
    up(_e?: FederatedPointerEvent): void;
    /**
     * TODO
     * @param _e
     */
    hover(_e?: FederatedPointerEvent): void;
    /** TODO */
    getText(): string;
    /** TODO */
    get isDown(): boolean;
    /** TODO */
    set enabled(value: boolean);
    /** TODO */
    get enabled(): boolean;
    /** TODO */
    set shown(value: boolean);
    /** TODO */
    get shown(): boolean;
    private _processUp;
    private _processUpOut;
    private _processOut;
    private _upOut;
    private _out;
}
//# sourceMappingURL=Button.d.ts.map